pragma solidity 0.4.15;

import "./BaseMultiSig.sol";

/// @title The conclave-managed version of the multisig wallet.
/// @author Ignacio Baixas (ignacio0buda.com)
/// @notice This contract is intended to be used by a third party to provide a multisig wallet
/// and receive refunds for both contract deployment and for each transaction execution. It can
/// also be usaed as a regular wallet if the manager is not available.
/// @dev its recommended that me manager uses at least (95000 + 9500 * signers + tx gasLimit) gas
/// when calling this contract.
contract ManagedMultiSig is BaseMultiSig {
  uint constant PRE_TX_GAS = 45000; // 25000 (if new) + 9700 (if value) + 9731 (refund)

  event Result(bool succeeded, uint fee);

  address public manager;

  function ManagedMultiSig() {
    manager = msg.sender;
  }

  /// @notice Activates the multisig, setting its owners and signing threshold. Its left to the
  /// manager's discretion to use a fair fee, therefore the user should never send more ether than
  /// requested by manager for activation.
  ///
  /// @param threshold_ The multisig signature threshold
  /// @param owners_ The wallet allowed signers adresses, in ascending order.
  /// @param fee_ The manager fee, it will be discounted from the current contract address.
  function activate(uint8 threshold_, address[] owners_, uint fee_) onlyManager onlyInactive {
    setup(threshold_, owners_);

    manager.send(fee_ > this.balance ? this.balance : fee_);
  }

  /// @notice Executes a signed transaction. The signatures must be passed in the same order as
  /// their corresponding signers address ordered in an ascending manner.
  /// @dev This method will refund the caller if it is the manager. The refund amount should be
  /// around 0% and 1.5% higher than the caller network fee.
  /// @param sigV_ The signatures V parts
  /// @param sigR_ The signatures R parts
  /// @param sigS_ The signatures S parts
  /// @param tx_ A RLP encoded standard ethereum transaction (as generated by most client)
  function execute(uint8[] sigV_, bytes32[] sigR_, bytes32[] sigS_, bytes tx_) onlyActive {
    validateSignatures(sigV_, sigR_, sigS_, tx_);

    var (nn, gp, gl, to, am, dt) = decodeTransaction(tx_);

    require(nn == fullNonce()); // check nonce
    require(gp == tx.gasprice); // check gas price to prevent front running attacks
    require(canCall(to));

    nonce = nonce + 1;

    if(msg.sender == manager) {
      uint beforeCallGas = msg.gas;
      require(beforeCallGas > (gl + PRE_TX_GAS)); // ensure there is enough gas for the user limit

      Result(
        to.call.gas(gl).value(am)(dt),
        payManager(baseGas(dt.length) + (beforeCallGas - msg.gas))
      );
    } else {
      require(to.call.gas(gl).value(am)(dt));
    }
  }

  // PRIVATE METHODS

  /// @dev base gas used to calculate the manager refund
  function baseGas(uint dataLength_) private returns (uint) {
    return 47800 + (uint(threshold) * 9500) + dataLength_ * 33;
  }

  /// @dev this method can be overriden by child contracts to implement custom policies
  function canCall(address _) private returns (bool) {
    return true;
  }

  /// @dev try to completely refund manager, if not enough balance send all
  function payManager(uint totalGas_) private returns (uint) {
    uint fee = totalGas_ * tx.gasprice;
    if (fee > this.balance) fee = this.balance;

    return manager.send(fee) ? fee : 0;
  }

  // MODIFIERS

  modifier onlyManager() {
    require(msg.sender == manager);
    _;
  }
}
